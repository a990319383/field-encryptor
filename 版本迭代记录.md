# 版本迭代记录

> 记录每个版本具体变化点及修复的bug项

|                         tag                          |                      含义                       |
| :--------------------------------------------------: | :---------------------------------------------: |
|       【<font color='orange'>**新增**</font>】       |            版本新增一些特性或者配置             |
|      【<font color='skyblue'>**调整**</font>】       |      对某些基础设计或代码结构进行优化调整       |
|     【<font color='tomato'>**bug修复**</font>】      | 某些极端场景下的小bug，没有对应场景不升级也没事 |
| 【<span style="color: #EE82EE;">**bug修复**</span>】 |           较为严重的bug，建议立即升级           |

## 3.6.0-alpha

> 状态：已发布中央仓库



> 此版本主要为了支持某些大小写敏感的库，顺便消灭满屏的toLowerCase()

### 全局变化

- 【<font color='orange'>**新增**</font>】提供数据库字段大小写敏感的支持  field.caseSensitive ，默认是大小写不敏感
- 【<font color='orange'>**新增**</font>】提供数据库标识符的引用符的配置 field.identifierQuote，默认通过DataSource读取
- 【<font color='skyblue'>**调整**</font>】重构项目中对表字段的匹配处理方式
  - 旧逻辑
    - 本地缓存时，将表字段全转换为小写，且将标识符引用符的 ` 和 " 两个符号全部忽略
    - 匹配时将字段名和表名都转为小写，屏蔽掉` “ 两个符号判断两者是否匹配
  - 新逻辑
    - 本地缓存时，缓存原字段，通过装饰器模式提供FieldHashMapWrapper，FieldHashSetWrapper集合，将信息存入新集合中
    - 匹配时，由于新集合将字段表名都转换为了FieldCacheKey，会根据当前配置屏蔽掉大小写差异
- 【<font color='skyblue'>**调整**</font>】自动通过DataSource读取表结构配置默认开启
  - 旧逻辑：默认关闭，需要手动开启
  - 新逻辑：默认开启，通过DataSource自动读取表结构信息可以获取到其它表结构信息，建议都开启，除非没权限（仅个别数据库会出现有读写权限，但是没权限通过DataSource读取表结构）

### 功能变化

#### 数据库字段自动加解密-db模式

- 【<font color='tomato'>**bug修复**</font>】group by 语法加解密处理时误调用语法解析器的visitor，导致没开启语法解析器功能，使用加解密功能时，程序报错

#### 数据库字段自动加解密-pojo模式

- 无

#### sql语法自动切换

- 无

#### 业务数据自动隔离

- 【<font color='skyblue'>**调整**</font>】逻辑处理时，减少对策略的getIsolationField(String tableName)方法的调用，避免某些复杂场景，频繁发起不必要的数据库或远程调用

#### 数据变更时维护默认值

- 无

#### 数据库字段查询脱敏

- 无



## 3.6.1-alpha

> 状态：未发布中央仓库，代码分支3.6.0，测试阶段



> 此版本主要为了对数据库字段加解密功能的某些很冷门的语法进行支持，tag归类到了bug修复
>
> 在有权限通过DataSource读取到表结构的情况下，之前版本有些无法支持的冷门语法可以提供支持了
>
> 特别是针对insert into table values(xxx) 这种不指定表字段顺序的语法

### 全局变化

- 【<font color='skyblue'>**调整**</font>】将sql语法解析时存储表拥有的字段信息的集合从Set<FieldInfoDto> 替换成了List<FieldInfoDto>，保障了字段的有序性，从而解决一些场景问题
- 【<font color='skyblue'>**调整**</font>】通过DataSource读取表字段的存储容器也替换成了有序的FieldLinkedListWarpper
- 【<font color='skyblue'>**调整**</font>】核心的缓存BaseFieldParseTable结构调整，存储每一层的表字段信息的Map替换为装饰类LayerHashMapWrapper，主要解决sql嵌套共享作用域处理的问题

```
#某些语法校验不严格的数据库支持下面的写法
# 这里的表2这层是允许访问表1的全部字段信息的，这个基本数据库都支持
#但是如果表2本身是一个嵌套查询，在嵌套查询内部有些数据库也支持访问表1的字段，这里主要解决这类场景
select * from 表A where 表A.字段1 in （ select 字段2 from 表B）
```

### 功能变化

#### 数据库字段自动加解密-db模式

- 【<font color='tomato'>**bug修复**</font>】在开启了自动读取表结构信息配置情况下( field.autoFill = true) 支持 insert into 表 values(字段...)

```
# 栗如： tb_user 有几个字段，其中phone字段需要密文存储
#下面的语句，在较早的版本中，未从DataSource中读取表结构信息，我们是不知道表字段顺序的，所以我们也无法知道phone字段是下面的第几个，所以无法对插入的值进行加密处理
#在本版本及以后，我们将获取到表结构顺序的前提下，对此类语法进行了兼容
insert into tb_user  values( ?,?,?,?,?,?,?,?)
```

- 【<font color='tomato'>**bug修复**</font>】in (select xxx from ) 这种in  子查询时，当子查询中使用到上游的密文字段时候处理错误

```
#栗如: tb_user 有几个字段，其中phone字段需要密文存储 ，in中子查询中where条件使用了tb_user的phone
# 旧逻辑中，in的子查询对上游表的字段使用都未做处理
select * from tb_user tu where tu.phone in (select tr.role_name from tb_role tr where tr.role_name = ? and tr.role_name = tu.phone)
```

- 【<font color='tomato'>**bug修复**</font>】当涉及上下游关联的语句的下游是嵌套查询时，上游是密文，加解密判断错误，不止是in，其它的涉及上下游关联的，下游是嵌套子查询也会有问题

```sql
#栗如： in的后面是一个嵌套子查询，且in前面是一个需要密文存储的字段
# 其中 tu.phone需要密文存储，此类场景会出现错误处理
select
  *
from tb_user tu
where tu.phone in (
	select 
	  tmp.*
	from
		(select
			tr.role_name   # 这里对role_name的处理旧版本也有问题，未考虑到上游phone的情况
		from tb_role tr
         where tu.phone = ?  # 这里对phone的处理旧版本是有问题的
	)tmp
)
```

#### 数据库字段自动加解密-pojo模式

- 【<font color='tomato'>**bug修复**</font>】同db模式的 insert into 表 values(字段...)的语法兼容
- 【<font color='tomato'>**bug修复**</font>】同db模式的 in (select xxx from ) 子查询时，当子查询中使用到上游的密文字段时候处理错误
- 【<font color='tomato'>**bug修复**</font>】同db模式的当涉及上下游关联的语句的下游是嵌套查询时，上游是密文，加解密判断错误，但是和DB模式略有区别的是，这里的子查询里面对结果集传入了mybatis的参数（一般没人这样写，仅为了程序完成性进行适配）

```
#备注：这种语法应该没人写，为了程序完整性，还是做了兼容
#栗如：tb_user的phone字段是密文存储，? 表示通过mybatis传参传入的
select * from tb_user tu where tu.phone in(select tmp.* from ( select ? from tb_role tr where tr.role_name = ?)tmp)
```

- 【<span style="color: #EE82EE;">**bug修复**</span>】在mybatis一级缓存生效的情况下，会出现对明文再次解密的bug

```
	@Override
    @Transactional //开启事务，保障下面的两次相关的查询属于一个SqlSession，从而使一级缓存生效
    public List<UserEntity> testCache() {
        String phone = "18111111111";
		//模拟第一次调用，这里会将返回结果的解密后进行缓存，注意，这里缓存的是明文
        UserEntity userEntity1 = userMapper.testGet(phone, phone);
        System.out.println("第一次查询:{}" + userEntity1);
        
		//模拟第二次调用，这里由于一级缓存，会拿到缓存的结果（明文！），对这个结果再次解密，就会报错
        UserEntity userEntity2 = userMapper.testGet(phone, phone);
        System.out.println("第二次查询:" + userEntity2);
        return Arrays.asList(userEntity1, userEntity2);
    }
```

#### sql语法自动切换

- 无

#### 业务数据自动隔离

- 【<font color='skyblue'>**调整**</font>】逻辑处理时，减少对策略的getIsolationField(String tableName)方法的调用，避免某些复杂场景，频繁发起不必要的数据库或远程调用

#### 数据变更时维护默认值

- 【<font color='tomato'>**bug修复**</font>】在开启了自动读取表结构信息配置情况下( field.autoFill = true) 支持insert into 表 values(字段...)
  - 在开启了自动读取表结构后，我们就可以在insert into不指定表名的情况下，知道表结构顺序，对对应字段进行默认值的维护

#### 数据库字段查询脱敏

- 【<span style="color: #EE82EE;">**bug修复**</span>】同pojo模式，在mybatis一级缓存生效的情况下，会出现字段进行两次脱敏